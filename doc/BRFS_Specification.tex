\documentclass[]{article}
\usepackage[a4paper,margin=1in]{geometry}
\usepackage{fancyhdr}
\usepackage{vhistory}
\usepackage{tabto}
\usepackage{tabularx}

\pagestyle{fancy}

%title page
\lhead{Working Draft}
\rhead{Revision 0.2b}

\title{
	\textbf{BRFS Specification} \\
	\large Bruno Filesystem (formerly BOOT-ROOT)
}
\author{
	Angel Ruiz Fernandez \textless arf20\textgreater \\
	Bruno Castro Garc√≠a  \textless bruneo32\textgreater
}

\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}


\begin{document}

	\maketitle
	\thispagestyle{fancy}
	
	\begin{abstract}
		This specification document describes the BRFS filesystem structure used to store data on storage devices. This provides a standard common description of the filesystem for developers to implement freely.
	\end{abstract}

	\begin{versionhistory}
		\vhEntry{0.1}{}{bruneo32}{Created}
		\vhEntry{0.2}{}{bruneo32}{Unknown}
		\vhEntry{0.2b}{}{bruneo32, arf20}{This document}
	\end{versionhistory}

	\pagebreak
	
	\tableofcontents
	\pagebreak
	
	\section{Introduction}
	\subsection{Scope}
	
	This document defines the Bruno Filesystem. As a filesystem it provides a way of structuring data in a block-based (i.e. LBA) storage device. It is meant for embedded systems where a ciomplex filesystem is not needed, this is not a replacement for any modern desktop filesystem such as ext4, because it lacks basic features of journaling. Although BRFS is able to address large volumes, it is not recommended.
	
	\subsection{Definitions}
	
	Key words will be refferred to with a \texttt{monospace font}.
	
	\begin{itemize}
		\item block: Minimum filesystem unit of data
		\item inode: File or directory entry
	\end{itemize}
	
	\subsection{Advantages and disadvantages}
	
	\begin{tabularx}{\textwidth}{X|X}
		\textbf{Advantages} & \textbf{Disadvantages} \\
		\hline
		TODO when defined
	\end{tabularx}

	\subsection{Volume layout}
	
	\begin{itemize}
		\item Superblock
		\item Root inode
		\item <other inodes>
	\end{itemize}

	\section{Superblock}
	
	The superblock records properties of the enclosed filesystem, such as the block size, pointer size and atribute size. It is 1 block in size. The remaining block will be padded with zeroes.
	
	\subsection{Superblock layout}
	
	\begin{tabular}{|l|l|l|} 
		\hline
		\textbf{Size (bytes)} & \textbf{Field (Unsigned integer)} & \textbf{Value} \\ [0.5ex] 
		\hline
		4 & Magic number & "BRFS" 0x42524653  \\ 
		\hline
		1 & Block size in LBAs & 0-255 (+1) \\
		\hline
		1 & Pointer size in bits & 16, 32, or 64 \\
		\hline
		1 & Attribute size in bytes & 0-255 (+1) \\
		\hline
		b-6 & Padding... & 0x00 \\
		\hline	
	\end{tabular}

	\subsection{Theorical limits}
	
	\begin{tabular}{|l|l|} 
		\hline
		\textbf{Property} & \textbf{Limit} \\ [0.5ex] 
		\hline
		Block size & 256 \\ 
		\hline
		Pointer size & 64 \\
		\hline
		Attribute size & 256 \\
		\hline
		Addresseable blocks & $2^{64}$ \\
		\hline	
		Addresseable LBAs & $256 \cdot 2^{64}$ \\
		\hline
		Absolute maxium capacity (512-byte LBA) & $512 \cdot 256 \cdot 2^{64} \approx $ 2 YiB \\
		\hline
	\end{tabular}\\

	The maximum capacity of the filesystem is calculated as follows
	\begin{equation}
		C = L \cdot B \cdot 2^p
	\end{equation}
	Where $p$ is pointer size, $B$ is block size and $L$ is LBA size.
	
	Some examples of reasonable configurations (assuming 512-byte LBA) are $p = 32$, $B = 8$, which gives 16 TiB capacity; or for more efficient storage, $p = 64$, $B = 1$: 8 ZiB; for embedded systems perhaps only a $p = 16$ $B = 1$ is needed, for 32 MiB.
	
	

\end{document}
